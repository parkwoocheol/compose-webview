{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to ComposeWebView","text":"<p>ComposeWebView is a powerful, flexible, and feature-rich WebView wrapper designed specifically for Jetpack Compose and Compose Multiplatform.</p> <p>It provides a unified API to control WebViews across Android, iOS, Desktop, and Web, with a strong focus on mobile productivity and developer experience.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li> <p> Multiplatform Support     ---</p> <p>Run your WebView logic on Android, iOS, Desktop (CEF), and Web (JS) with a single codebase.</p> </li> <li> <p> Advanced JSBridge     ---</p> <p>Promise-based, type-safe communication between Kotlin and JavaScript. No more callback hell.</p> </li> <li> <p> Reactive State     ---</p> <p>Monitor URL changes, loading progress, and errors using standard Compose state objects.</p> </li> <li> <p> Rich Capabilities     ---</p> <p>Built-in support for File Uploads, Fullscreen Video, and Custom Views.</p> </li> </ul>"},{"location":"#platform-support","title":"\ud83d\udcf1 Platform Support","text":"Platform Implementation Status Note Android <code>AndroidView</code> (WebView)  Stable Full feature support iOS <code>UIKitView</code> (WKWebView)  Stable Full feature support (Seamless JS Bridge) Desktop <code>SwingPanel</code> (CEF via KCEF)  Experimental WIP: Basic browsing works. KCEF integration in progress. Web (JS) <code>Iframe</code> (DOM)  Experimental WIP: Basic navigation and <code>postMessage</code> bridge. <p>Project Focus: Mobile Productivity</p> <p>This library is optimized for Mobile (Android &amp; iOS) development. While Desktop and Web are supported, they are currently experimental. If you need a battle-tested solution primarily for Desktop/Web, other libraries might be a better fit.</p>"},{"location":"#get-started","title":"\ud83d\ude80 Get Started","text":"<p>Ready to start building? Check out the Getting Started guide to add <code>compose-webview</code> to your project in minutes.</p> <p>Get Started</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>Before you begin, ensure your project meets the following requirements:</p> <ul> <li>Android API Level: 24+</li> <li>iOS Deployment Target: 14.0+</li> <li>Java Version: 11+</li> <li>Jetpack Compose / Compose Multiplatform: 1.9.3+</li> <li>Kotlin: 2.2.0+</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p><code>compose-webview</code> is hosted on JitPack. You need to add the JitPack repository to your project.</p>"},{"location":"getting-started/#1-add-repository","title":"1. Add Repository","text":"Kotlin (<code>settings.gradle.kts</code>)Groovy (<code>settings.gradle</code>) <pre><code>dependencyResolutionManagement {\n    repositories {\n        google()\n        mavenCentral()\n        maven { url = uri(\"https://jitpack.io\") }\n    }\n}\n</code></pre> <pre><code>dependencyResolutionManagement {\n    repositories {\n        google()\n        mavenCentral()\n        maven { url = \"https://jitpack.io\" }\n    }\n}\n</code></pre>"},{"location":"getting-started/#2-add-dependency","title":"2. Add Dependency","text":"<p>Add the dependency to your shared module's build file (usually <code>commonMain</code>).</p> Kotlin (<code>build.gradle.kts</code>)Groovy (<code>build.gradle</code>) <pre><code>kotlin {\n    sourceSets {\n        commonMain.dependencies {\n            implementation(\"com.github.parkwoocheol:compose-webview:&lt;version&gt;\")\n        }\n    }\n}\n</code></pre> <pre><code>kotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation 'com.github.parkwoocheol:compose-webview:&lt;version&gt;'\n            }\n        }\n    }\n}\n</code></pre> <p>Latest Version</p> <p>Check the Release Badge for the latest version number.</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Here is the minimal code required to get a functional WebView running in your Compose application.</p>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>Use <code>ComposeWebView</code> directly with a URL.</p> BasicWebView.kt<pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.parkwoocheol.composewebview.ComposeWebView\nimport com.parkwoocheol.composewebview.WebViewSettings\n\n@Composable\nfun MyBrowser() {\n    ComposeWebView(\n        url = \"https://google.com\",\n        modifier = Modifier.fillMaxSize(),\n        settings = WebViewSettings(\n            javaScriptEnabled = true,\n            domStorageEnabled = true\n        )\n    )\n}\n</code></pre>"},{"location":"getting-started/#with-state-controller","title":"With State &amp; Controller","text":"<p>For most apps, you will want to control navigation (Back/Forward) or react to loading states. Use <code>rememberSaveableWebViewState</code> and <code>rememberWebViewController</code>.</p> ControlledWebView.kt<pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.LinearProgressIndicator\nimport androidx.compose.runtime.Composable\nimport com.parkwoocheol.composewebview.*\n\n@Composable\nfun ControlledBrowser() {\n    // 1. Create State and Controller\n    val state = rememberSaveableWebViewState(url = \"https://github.com\")\n    val controller = rememberWebViewController()\n\n    Column(modifier = Modifier.fillMaxSize()) {\n        // 2. Show Loading Indicator\n        if (state.isLoading) {\n            LinearProgressIndicator(\n                progress = (state.loadingState as? LoadingState.Loading)?.progress ?: 0f,\n                modifier = Modifier.fillMaxWidth()\n            )\n        }\n\n        // 3. The WebView\n        ComposeWebView(\n            state = state,\n            controller = controller,\n            modifier = Modifier.weight(1f),\n            settings = WebViewSettings(\n                javaScriptEnabled = true,\n                domStorageEnabled = true\n            )\n        )\n    }\n}\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic WebView, explore the advanced features:</p> <ul> <li>State Management: Learn about persistent vs transient state.</li> <li>JS Bridge: Communicate between Kotlin and JavaScript.</li> <li>Lifecycle &amp; Errors: Handle app lifecycle and loading errors.</li> </ul>"},{"location":"api/compose-webview/","title":"ComposeWebView API","text":"<p>The primary entry point for the library is the <code>ComposeWebView</code> composable.</p>"},{"location":"api/compose-webview/#signatures","title":"Signatures","text":""},{"location":"api/compose-webview/#1-basic-overload","title":"1. Basic Overload","text":"<p>Use this when you just want to load a URL without managing state explicitly.</p> <pre><code>@Composable\nfun ComposeWebView(\n    url: String,\n    modifier: Modifier = Modifier,\n    settings: WebViewSettings = WebViewSettings.Default,\n    controller: WebViewController = rememberWebViewController(),\n    javaScriptInterfaces: Map&lt;String, Any&gt; = emptyMap(),\n    onCreated: (WebView) -&gt; Unit = {},\n    onDispose: (WebView) -&gt; Unit = {},\n    client: ComposeWebViewClient = remember { ComposeWebViewClient() },\n    chromeClient: ComposeWebChromeClient = remember { ComposeWebChromeClient() },\n    factory: ((PlatformContext) -&gt; WebView)? = null,\n    loadingContent: @Composable () -&gt; Unit = {},\n    errorContent: @Composable (List&lt;WebViewError&gt;) -&gt; Unit = {},\n    jsAlertContent: @Composable (JsDialogState.Alert) -&gt; Unit = {},\n    jsConfirmContent: @Composable (JsDialogState.Confirm) -&gt; Unit = {},\n    jsPromptContent: @Composable (JsDialogState.Prompt) -&gt; Unit = {},\n    customViewContent: (@Composable (CustomViewState) -&gt; Unit)? = null,\n    onDownloadStart: ((String, String, String, String, Long) -&gt; Unit)? = null,\n    onFindResultReceived: ((Int, Int, Boolean) -&gt; Unit)? = null,\n)\n</code></pre>"},{"location":"api/compose-webview/#2-state-aware-overload","title":"2. State-Aware Overload","text":"<p>Use this when you are providing a <code>WebViewState</code> (e.g., from <code>rememberSaveableWebViewState</code>).</p> <pre><code>@Composable\nfun ComposeWebView(\n    state: WebViewState,\n    modifier: Modifier = Modifier,\n    controller: WebViewController = rememberWebViewController(),\n    // ... all other parameters are identical\n)\n</code></pre>"},{"location":"api/compose-webview/#parameters","title":"Parameters","text":"Parameter Type Description Platform Support <code>url</code> <code>String</code> The initial URL to load. Ignored if <code>state</code> is provided and already has content. All platforms <code>state</code> <code>WebViewState</code> The <code>WebViewState</code> object holding the content and status of the WebView. All platforms <code>modifier</code> <code>Modifier</code> The modifier to be applied to the layout. All platforms <code>settings</code> <code>WebViewSettings</code> Configuration settings for WebView behavior (user agent, JavaScript, cache, zoom, etc.). Android (full), iOS (partial), Desktop (partial), Web (none) <code>controller</code> <code>WebViewController</code> The <code>WebViewController</code> for programmatic control (load, back, forward, zoom, etc.). All platforms* <code>javaScriptInterfaces</code> <code>Map&lt;String, Any&gt;</code> Map of native objects to inject into JavaScript. Key is the JS object name. Android, Desktop <code>jsBridge</code> <code>WebViewJsBridge?</code> The <code>WebViewJsBridge</code> instance for type-safe, promise-based communication. All platforms <code>onCreated</code> <code>(WebView) -&gt; Unit</code> Callback invoked when the native <code>WebView</code> instance is created. All platforms <code>onDispose</code> <code>(WebView) -&gt; Unit</code> Callback invoked when the WebView is about to be destroyed. All platforms <code>client</code> <code>ComposeWebViewClient</code> Custom <code>ComposeWebViewClient</code> (wraps <code>WebViewClient</code>). All platforms <code>chromeClient</code> <code>ComposeWebChromeClient</code> Custom <code>ComposeWebChromeClient</code> (wraps <code>WebChromeClient</code>). All platforms <code>factory</code> <code>((PlatformContext) -&gt; WebView)?</code> Optional factory to provide a custom <code>WebView</code> instance. Android, iOS <code>loadingContent</code> <code>@Composable () -&gt; Unit</code> Composable to display while the page is loading. All platforms <code>errorContent</code> <code>@Composable (List&lt;WebViewError&gt;) -&gt; Unit</code> Composable replacement content when an error occurs. All platforms <code>jsAlertContent</code> <code>@Composable (JsDialogState.Alert) -&gt; Unit</code> Custom UI for JavaScript <code>alert()</code> dialogs. Android, iOS <code>jsConfirmContent</code> <code>@Composable (JsDialogState.Confirm) -&gt; Unit</code> Custom UI for JavaScript <code>confirm()</code> dialogs. Android, iOS <code>jsPromptContent</code> <code>@Composable (JsDialogState.Prompt) -&gt; Unit</code> Custom UI for JavaScript <code>prompt()</code> dialogs. Android, iOS <code>customViewContent</code> <code>(@Composable (CustomViewState) -&gt; Unit)?</code> Custom view content (e.g., fullscreen video). Android <code>onDownloadStart</code> <code>((String, String, String, String, Long) -&gt; Unit)?</code> Callback for download requests (url, userAgent, contentDisposition, mimeType, contentLength). Android, iOS (partial) <code>onFindResultReceived</code> <code>((Int, Int, Boolean) -&gt; Unit)?</code> Callback for text search results (activeMatchOrdinal, numberOfMatches, isDoneCounting). Android <p>* Controller: All platforms support basic navigation, but some features (like zoom) are platform-specific. See <code>WebViewController</code> documentation for details.</p>"},{"location":"api/compose-webview/#client-configuration","title":"Client Configuration","text":"<p>Starting from version 1.4.0, you can configure WebView clients using convenient composable functions instead of extending classes or passing individual callback parameters.</p>"},{"location":"api/compose-webview/#using-rememberwebviewclient","title":"Using rememberWebViewClient","text":"<p>Configure navigation and page lifecycle events:</p> <pre><code>val client = rememberWebViewClient {\n    onPageStarted { view, url, favicon -&gt;\n        println(\"Started loading: $url\")\n    }\n\n    onPageFinished { view, url -&gt;\n        println(\"Finished loading: $url\")\n    }\n\n    onReceivedError { view, request, error -&gt;\n        println(\"Error: ${error?.description}\")\n    }\n\n    shouldOverrideUrlLoading { view, request -&gt;\n        // Return true to prevent loading\n        false\n    }\n}\n\nComposeWebView(\n    state = rememberSaveableWebViewState(url = \"https://example.com\"),\n    client = client,\n    modifier = Modifier.fillMaxSize()\n)\n</code></pre>"},{"location":"api/compose-webview/#using-rememberwebchromeclient","title":"Using rememberWebChromeClient","text":"<p>Configure progress tracking and console messages:</p> <pre><code>val chromeClient = rememberWebChromeClient {\n    onProgressChanged { view, progress -&gt;\n        println(\"Loading: $progress%\")\n    }\n\n    onConsoleMessage { view, message -&gt;\n        when (message.level) {\n            ConsoleMessageLevel.ERROR -&gt; {\n                Log.e(\"WebView\", \"[JS Error] ${message.message}\")\n            }\n            else -&gt; {\n                Log.d(\"WebView\", \"[JS] ${message.message}\")\n            }\n        }\n        false // Return true to suppress default console logging\n    }\n}\n\nComposeWebView(\n    state = rememberSaveableWebViewState(url = \"https://example.com\"),\n    chromeClient = chromeClient,\n    modifier = Modifier.fillMaxSize()\n)\n</code></pre>"},{"location":"api/compose-webview/#method-chaining","title":"Method Chaining","text":"<p>You can also configure clients using method chaining:</p> <pre><code>val client = rememberWebViewClient()\n    .onPageStarted { view, url, favicon -&gt;\n        println(\"Started: $url\")\n    }\n    .onPageFinished { view, url -&gt;\n        println(\"Finished: $url\")\n    }\n</code></pre> <p>For more detailed examples and use cases, see the Client Configuration Guide.</p>"},{"location":"api/compose-webview/#see-also","title":"See Also","text":"<ul> <li>Client Configuration Guide - Detailed guide on configuring WebView clients</li> <li>State Management - Managing WebView state</li> <li>Error Handling - Handling errors and edge cases</li> </ul>"},{"location":"api/types/","title":"Types API","text":"<p>Reference documentation for the core classes used in the library.</p>"},{"location":"api/types/#webviewstate","title":"<code>WebViewState</code>","text":"<p>Holds the reactive state of the WebView.</p>"},{"location":"api/types/#properties","title":"Properties","text":"Name Type Description Platform Support <code>lastLoadedUrl</code> <code>String?</code> The most recently loaded URL. All platforms <code>content</code> <code>WebContent</code> Sealed class representing the content (Url, Data, or Post). All platforms <code>isLoading</code> <code>Boolean</code> Whether the WebView is currently loading a page. All platforms <code>loadingState</code> <code>LoadingState</code> Detailed loading progress state (Initializing, Loading, Finished, Failed, Cancelled). All platforms* <code>pageTitle</code> <code>String?</code> The current page title. All platforms <code>pageIcon</code> <code>PlatformBitmap?</code> The current page favicon. Android, iOS, Desktop <code>scrollPosition</code> <code>ScrollPosition</code> Current scroll position (x, y) in pixels. Android (real-time), iOS (100ms polling), Web (CORS-limited) <code>errorsForCurrentRequest</code> <code>List&lt;WebViewError&gt;</code> Errors that occurred during the current page load. Android, iOS, Desktop (partial), Web (limited) <code>jsDialogState</code> <code>JsDialogState?</code> Active JavaScript dialog (Alert, Confirm, Prompt). Android, iOS <code>customViewState</code> <code>CustomViewState?</code> Custom view state (e.g., fullscreen video). Android <p>* LoadingState progress: Android (real-time), iOS (100ms polling), Desktop/Web (limited)</p>"},{"location":"api/types/#webviewcontroller","title":"<code>WebViewController</code>","text":"<p>Controls the navigation and execution of the WebView.</p>"},{"location":"api/types/#properties_1","title":"Properties","text":"Name Type Description Platform Support <code>canGoBack</code> <code>Boolean</code> Whether the WebView can navigate back. All platforms <code>canGoForward</code> <code>Boolean</code> Whether the WebView can navigate forward. All platforms"},{"location":"api/types/#core-navigation-methods","title":"Core Navigation Methods","text":"Method Platform Support Notes <code>loadUrl(url: String, headers: Map&lt;String, String&gt; = emptyMap())</code> All platforms Headers: Android/iOS only <code>loadHtml(html: String, baseUrl: String? = null, ...)</code> All platforms Full data loading control <code>postUrl(url: String, postData: ByteArray)</code> Android, iOS HTTP POST request <code>navigateBack()</code> All platforms Check <code>canGoBack</code> first <code>navigateForward()</code> All platforms Check <code>canGoForward</code> first <code>reload()</code> All platforms Reload current page <code>stopLoading()</code> All platforms Stop page load"},{"location":"api/types/#javascript-execution","title":"JavaScript Execution","text":"Method Platform Support Notes <code>evaluateJavascript(script: String, callback: ((String) -&gt; Unit)? = null)</code> All platforms Execute JS and receive result"},{"location":"api/types/#zoom-control","title":"Zoom Control","text":"Method Platform Support Notes <code>zoomIn(): Boolean</code> Android, Desktop iOS: Not supported (pinch-to-zoom only) <code>zoomOut(): Boolean</code> Android, Desktop iOS: Not supported (pinch-to-zoom only) <code>zoomBy(factor: Float)</code> Android, Desktop iOS: Not supported"},{"location":"api/types/#text-search","title":"Text Search","text":"Method Platform Support Notes <code>findAllAsync(find: String)</code> Android Highlight all matches <code>findNext(forward: Boolean)</code> Android Navigate through matches <code>clearMatches()</code> Android Clear search highlights"},{"location":"api/types/#scroll-control","title":"Scroll Control","text":"Method Platform Support Notes <code>scrollTo(x: Int, y: Int)</code> Android, iOS, Desktop Absolute scroll position <code>scrollBy(x: Int, y: Int)</code> Android, iOS, Desktop Relative scroll offset <code>pageUp(top: Boolean)</code> Android Scroll up one page <code>pageDown(bottom: Boolean)</code> Android Scroll down one page"},{"location":"api/types/#cache-history-management","title":"Cache &amp; History Management","text":"Method Platform Support Notes <code>clearCache(includeDiskFiles: Boolean)</code> Android, iOS, Desktop Clear WebView cache <code>clearHistory()</code> Android, iOS, Desktop Clear navigation history <code>clearSslPreferences()</code> Android Clear SSL certificate decisions <code>clearFormData()</code> Android Clear form autofill data"},{"location":"api/types/#file-operations","title":"File Operations","text":"Method Platform Support Notes <code>saveWebArchive(filename: String)</code> Android Save page as .mht file"},{"location":"api/types/#webviewjsbridge","title":"<code>WebViewJsBridge</code>","text":"<p>Helper class for managing the connection between Kotlin and JavaScript.</p>"},{"location":"api/types/#methods","title":"Methods","text":"Method Description Platform Support <code>register&lt;T, R&gt;(name: String, handler: (T) -&gt; R)</code> Registers a handler that receives type <code>T</code> from JS and returns type <code>R</code>. All platforms <code>emit(eventName: String, data: Any)</code> Emits an event to JavaScript. The data object is automatically serialized to JSON. All platforms <code>call&lt;T&gt;(functionName: String, args: Any, callback: (T) -&gt; Unit)</code> Calls a JavaScript function and receives the result. All platforms"},{"location":"api/types/#webviewsettings","title":"<code>WebViewSettings</code>","text":"<p>Configuration settings for WebView behavior across all platforms.</p>"},{"location":"api/types/#properties_2","title":"Properties","text":"Setting Type Default Platform Support Notes <code>userAgent</code> <code>String?</code> <code>null</code> Android, iOS, Desktop Custom user agent string <code>javaScriptEnabled</code> <code>Boolean</code> <code>true</code> Android, iOS*, Desktop *iOS: Always enabled <code>domStorageEnabled</code> <code>Boolean</code> <code>true</code> Android, iOS, Desktop (partial) localStorage/sessionStorage <code>cacheMode</code> <code>CacheMode</code> <code>DEFAULT</code> Android, iOS (partial), Desktop (partial) Cache behavior control <code>allowFileAccess</code> <code>Boolean</code> <code>false</code> Android, iOS (partial), Desktop (partial) Access to file:// URLs <code>allowContentAccess</code> <code>Boolean</code> <code>false</code> Android Access to content:// URLs <code>supportZoom</code> <code>Boolean</code> <code>true</code> Android, iOS**, Desktop **iOS: Pinch-to-zoom only <code>loadWithOverviewMode</code> <code>Boolean</code> <code>true</code> Android Load page with overview mode <code>useWideViewPort</code> <code>Boolean</code> <code>true</code> Android, iOS (partial), Desktop (partial) Viewport meta tag support <code>allowFileAccessFromFileURLs</code> <code>Boolean</code> <code>false</code> Android, iOS (partial), Desktop (partial) Security setting <code>allowUniversalAccessFromFileURLs</code> <code>Boolean</code> <code>false</code> Android, iOS (partial), Desktop (partial) Security setting <code>mediaPlaybackRequiresUserAction</code> <code>Boolean</code> <code>false</code> Android, iOS, Desktop (partial) Autoplay control"},{"location":"api/types/#cachemode-enum","title":"CacheMode Enum","text":"Value Description Platform Support <code>DEFAULT</code> Use cache when available All platforms <code>CACHE_ELSE_NETWORK</code> Prefer cache, fallback to network Android, iOS (partial), Desktop (partial) <code>NO_CACHE</code> Always load from network Android, iOS (partial), Desktop (partial) <code>CACHE_ONLY</code> Only use cache, don't fetch Android, iOS (partial), Desktop (partial)"},{"location":"api/types/#scrollposition","title":"<code>ScrollPosition</code>","text":"<p>Represents the current scroll position of the WebView.</p> <pre><code>@Immutable\ndata class ScrollPosition(\n    val x: Int = 0,  // Horizontal scroll position in pixels\n    val y: Int = 0   // Vertical scroll position in pixels\n)\n</code></pre> <p>Platform Support:</p> <ul> <li>Android: Real-time updates via <code>setOnScrollChangeListener</code></li> <li>iOS: 100ms polling of <code>scrollView.contentOffset</code></li> <li>Desktop: Not supported (KCEF limitations)</li> <li>Web: CORS-limited (same-origin iframes only)</li> </ul>"},{"location":"api/types/#consolemessage","title":"<code>ConsoleMessage</code>","text":"<p>Represents a JavaScript console message from the WebView.</p> <pre><code>data class ConsoleMessage(\n    val message: String,           // Console message text\n    val sourceId: String = \"\",     // Source file URL\n    val lineNumber: Int = 0,       // Line number in source\n    val level: ConsoleMessageLevel // Severity level\n)\n</code></pre>"},{"location":"api/types/#consolemessagelevel-enum","title":"ConsoleMessageLevel Enum","text":"Level Description <code>LOG</code> Standard console.log() <code>DEBUG</code> console.debug() <code>WARNING</code> console.warn() <code>ERROR</code> console.error() <code>TIP</code> Browser tip/info <p>Platform Support: Android, iOS</p>"},{"location":"api/types/#webviewerror","title":"<code>WebViewError</code>","text":"<p>Represents an error that occurred during page loading.</p> <pre><code>data class WebViewError(\n    val errorCode: Int,           // Platform-specific error code\n    val description: String,      // Human-readable description\n    val failingUrl: String? = null // The URL that failed to load\n)\n</code></pre> <p>Platform-Specific Error Codes:</p> <ul> <li>Android: Maps to <code>WebViewClient</code> error constants (e.g., <code>ERROR_HOST_LOOKUP</code>, <code>ERROR_CONNECT</code>)</li> <li>iOS: Maps to <code>NSURLError</code> codes (e.g., <code>NSURLErrorNotConnectedToInternet</code>)</li> <li>Desktop/Web: Limited error information</li> </ul>"},{"location":"api/types/#loadingstate","title":"<code>LoadingState</code>","text":"<p>Sealed class representing the loading state of the WebView.</p> State Description Platform Support <code>Initializing</code> WebView is being initialized All platforms <code>Loading(progress: Float)</code> Page is loading (0.0 to 1.0) Android (real-time), iOS (100ms polling), Desktop/Web (limited) <code>Finished</code> Page finished loading All platforms <code>Failed(error: WebViewError)</code> Page load failed Android, iOS, Desktop (partial), Web (limited) <code>Cancelled</code> Load was cancelled All platforms"},{"location":"api/types/#jsdialogstate","title":"<code>JsDialogState</code>","text":"<p>Sealed class representing JavaScript dialog state (alert, confirm, prompt).</p>"},{"location":"api/types/#variants","title":"Variants","text":"<pre><code>sealed class JsDialogState {\n    data class Alert(\n        val message: String,\n        val callback: () -&gt; Unit\n    ) : JsDialogState()\n\n    data class Confirm(\n        val message: String,\n        val result: (Boolean) -&gt; Unit\n    ) : JsDialogState()\n\n    data class Prompt(\n        val message: String,\n        val defaultValue: String,\n        val result: (String?) -&gt; Unit\n    ) : JsDialogState()\n}\n</code></pre> <p>Platform Support: Android, iOS</p>"},{"location":"guides/client-configuration/","title":"Configuring WebView Clients","text":"<p>This guide covers how to configure WebView clients to handle navigation events, progress updates, console messages, and more using the convenient <code>rememberWebViewClient</code> and <code>rememberWebChromeClient</code> composables.</p>"},{"location":"guides/client-configuration/#overview","title":"Overview","text":"<p>ComposeWebView provides two main client types:</p> <ul> <li><code>ComposeWebViewClient</code>: Handles navigation events (page started, finished, errors, URL loading)</li> <li><code>ComposeWebChromeClient</code>: Handles UI events (progress, console messages, JavaScript dialogs)</li> </ul> <p>Starting from version 1.4.0, you can configure these clients using convenient composable functions.</p>"},{"location":"guides/client-configuration/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/client-configuration/#webviewclient-configuration","title":"WebViewClient Configuration","text":"<p>Configure navigation and page lifecycle events:</p> <pre><code>@Composable\nfun MyWebView() {\n    val state = rememberSaveableWebViewState(url = \"https://example.com\")\n\n    val client = rememberWebViewClient {\n        onPageStarted { view, url, favicon -&gt;\n            println(\"Started loading: $url\")\n        }\n\n        onPageFinished { view, url -&gt;\n            println(\"Finished loading: $url\")\n        }\n\n        onReceivedError { view, request, error -&gt;\n            println(\"Error: ${error?.description}\")\n        }\n\n        shouldOverrideUrlLoading { view, request -&gt;\n            // Return true to prevent loading\n            val url = request?.url ?: return@shouldOverrideUrlLoading false\n\n            // Handle custom URL schemes\n            if (url.startsWith(\"myapp://\")) {\n                // Handle custom scheme\n                return@shouldOverrideUrlLoading true\n            }\n\n            false // Allow normal navigation\n        }\n    }\n\n    ComposeWebView(\n        state = state,\n        client = client,\n        modifier = Modifier.fillMaxSize()\n    )\n}\n</code></pre>"},{"location":"guides/client-configuration/#webchromeclient-configuration","title":"WebChromeClient Configuration","text":"<p>Configure progress tracking and console messages:</p> <pre><code>@Composable\nfun MyWebView() {\n    val state = rememberSaveableWebViewState(url = \"https://example.com\")\n    var loadingProgress by remember { mutableStateOf(0) }\n\n    val chromeClient = rememberWebChromeClient {\n        onProgressChanged { view, progress -&gt;\n            loadingProgress = progress\n            println(\"Loading: $progress%\")\n        }\n\n        onConsoleMessage { view, message -&gt;\n            when (message.level) {\n                ConsoleMessageLevel.ERROR -&gt; {\n                    Log.e(\"WebView\", \"[JS Error] ${message.message}\")\n                }\n                ConsoleMessageLevel.WARNING -&gt; {\n                    Log.w(\"WebView\", \"[JS Warning] ${message.message}\")\n                }\n                else -&gt; {\n                    Log.d(\"WebView\", \"[JS] ${message.message}\")\n                }\n            }\n            false // Return true to suppress default console logging\n        }\n\n        onPermissionRequest { request -&gt;\n            // Handle permission requests (platform-specific)\n            // e.g., camera, microphone, location\n        }\n    }\n\n    Column(Modifier.fillMaxSize()) {\n        if (loadingProgress &lt; 100) {\n            LinearProgressIndicator(\n                progress = { loadingProgress / 100f },\n                modifier = Modifier.fillMaxWidth()\n            )\n        }\n\n        ComposeWebView(\n            state = state,\n            chromeClient = chromeClient,\n            modifier = Modifier.weight(1f)\n        )\n    }\n}\n</code></pre>"},{"location":"guides/client-configuration/#method-chaining","title":"Method Chaining","text":"<p>You can also configure clients using method chaining:</p> <pre><code>@Composable\nfun ChainedExample() {\n    val client = rememberWebViewClient()\n        .onPageStarted { view, url, favicon -&gt;\n            println(\"Started: $url\")\n        }\n        .onPageFinished { view, url -&gt;\n            println(\"Finished: $url\")\n        }\n        .onReceivedError { view, request, error -&gt;\n            println(\"Error: $error\")\n        }\n\n    val chromeClient = rememberWebChromeClient()\n        .onProgressChanged { view, progress -&gt;\n            println(\"Progress: $progress%\")\n        }\n        .onConsoleMessage { view, message -&gt;\n            println(\"[Console] ${message.message}\")\n            false\n        }\n\n    ComposeWebView(\n        state = rememberSaveableWebViewState(url = \"https://example.com\"),\n        client = client,\n        chromeClient = chromeClient,\n        modifier = Modifier.fillMaxSize()\n    )\n}\n</code></pre>"},{"location":"guides/client-configuration/#advanced-customization","title":"Advanced Customization","text":"<p>For advanced scenarios requiring full control, you can still extend the client classes directly:</p> <pre><code>@Composable\nfun AdvancedClient() {\n    val client = remember {\n        object : ComposeWebViewClient() {\n            override fun onPageStarted(\n                view: WebView?,\n                url: String?,\n                favicon: PlatformBitmap?\n            ) {\n                super.onPageStarted(view, url, favicon)\n                // Custom logic before default handling\n            }\n\n            override fun onPageFinished(view: WebView?, url: String?) {\n                super.onPageFinished(view, url)\n\n                // Inject custom JavaScript\n                view?.evaluateJavascript(\"\"\"\n                    console.log('Page loaded!');\n                    // Your custom JS code\n                \"\"\") { result -&gt;\n                    println(\"JS result: $result\")\n                }\n            }\n        }\n    }\n\n    ComposeWebView(\n        state = rememberSaveableWebViewState(url = \"https://example.com\"),\n        client = client,\n        modifier = Modifier.fillMaxSize()\n    )\n}\n</code></pre>"},{"location":"guides/client-configuration/#available-handlers","title":"Available Handlers","text":""},{"location":"guides/client-configuration/#composewebviewclient","title":"ComposeWebViewClient","text":"Handler Parameters Return Type Description <code>onPageStarted</code> <code>(WebView?, String?, PlatformBitmap?)</code> <code>Unit</code> Called when page starts loading <code>onPageFinished</code> <code>(WebView?, String?)</code> <code>Unit</code> Called when page finishes loading <code>onReceivedError</code> <code>(WebView?, PlatformWebResourceRequest?, PlatformWebResourceError?)</code> <code>Unit</code> Called when an error occurs <code>shouldOverrideUrlLoading</code> <code>(WebView?, PlatformWebResourceRequest?)</code> <code>Boolean</code> Return <code>true</code> to prevent navigation"},{"location":"guides/client-configuration/#composewebchromeclient","title":"ComposeWebChromeClient","text":"Handler Parameters Return Type Description <code>onProgressChanged</code> <code>(WebView?, Int)</code> <code>Unit</code> Called when loading progress changes (0-100) <code>onConsoleMessage</code> <code>(WebView?, ConsoleMessage)</code> <code>Boolean</code> Called when JS console logs. Return <code>true</code> to suppress default <code>onPermissionRequest</code> <code>(PlatformPermissionRequest)</code> <code>Unit</code> Called when permission is requested (platform-specific)"},{"location":"guides/client-configuration/#platform-support","title":"Platform Support","text":"Handler Android iOS Desktop Web <code>onPageStarted</code> \u2705 \u2705 \u2705 \u274c <code>onPageFinished</code> \u2705 \u2705 \u2705 \u2705 <code>onReceivedError</code> \u2705 \u2705 \u26a0\ufe0f \u274c <code>shouldOverrideUrlLoading</code> \u2705 \u2705 \u2705 \u274c <code>onProgressChanged</code> \u2705 \u2705 \u274c \u274c <code>onConsoleMessage</code> \u2705 \u2705 \u274c \u274c <code>onPermissionRequest</code> \u2705 \u26a0\ufe0f \u274c \u274c <p>Legend: \u2705 Full Support | \u26a0\ufe0f Partial/Limited | \u274c Not Supported</p>"},{"location":"guides/client-configuration/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/client-configuration/#loading-indicator","title":"Loading Indicator","text":"<pre><code>@Composable\nfun WebViewWithProgress() {\n    val state = rememberSaveableWebViewState(url = \"https://example.com\")\n    var isLoading by remember { mutableStateOf(false) }\n    var progress by remember { mutableStateOf(0) }\n\n    val client = rememberWebViewClient {\n        onPageStarted { _, _, _ -&gt; isLoading = true }\n        onPageFinished { _, _ -&gt; isLoading = false }\n    }\n\n    val chromeClient = rememberWebChromeClient {\n        onProgressChanged { _, p -&gt; progress = p }\n    }\n\n    Column(Modifier.fillMaxSize()) {\n        if (isLoading) {\n            LinearProgressIndicator(\n                progress = { progress / 100f },\n                modifier = Modifier.fillMaxWidth()\n            )\n        }\n\n        ComposeWebView(\n            state = state,\n            client = client,\n            chromeClient = chromeClient,\n            modifier = Modifier.weight(1f)\n        )\n    }\n}\n</code></pre>"},{"location":"guides/client-configuration/#custom-url-handling","title":"Custom URL Handling","text":"<pre><code>@Composable\nfun CustomUrlHandling() {\n    val context = LocalContext.current\n\n    val client = rememberWebViewClient {\n        shouldOverrideUrlLoading { view, request -&gt;\n            val url = request?.url ?: return@shouldOverrideUrlLoading false\n\n            when {\n                url.startsWith(\"tel:\") -&gt; {\n                    // Handle phone number\n                    context.startActivity(Intent(Intent.ACTION_DIAL, Uri.parse(url)))\n                    true\n                }\n                url.startsWith(\"mailto:\") -&gt; {\n                    // Handle email\n                    context.startActivity(Intent(Intent.ACTION_SENDTO, Uri.parse(url)))\n                    true\n                }\n                url.startsWith(\"myapp://\") -&gt; {\n                    // Handle custom scheme\n                    handleCustomScheme(url)\n                    true\n                }\n                else -&gt; false\n            }\n        }\n    }\n\n    ComposeWebView(\n        state = rememberSaveableWebViewState(url = \"https://example.com\"),\n        client = client,\n        modifier = Modifier.fillMaxSize()\n    )\n}\n</code></pre>"},{"location":"guides/client-configuration/#error-handling","title":"Error Handling","text":"<pre><code>@Composable\nfun ErrorHandlingWebView() {\n    val state = rememberSaveableWebViewState(url = \"https://example.com\")\n    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }\n\n    val client = rememberWebViewClient {\n        onReceivedError { view, request, error -&gt;\n            errorMessage = error?.description ?: \"Unknown error\"\n        }\n\n        onPageFinished { _, _ -&gt;\n            errorMessage = null // Clear error on successful load\n        }\n    }\n\n    Box(Modifier.fillMaxSize()) {\n        ComposeWebView(\n            state = state,\n            client = client,\n            modifier = Modifier.fillMaxSize()\n        )\n\n        errorMessage?.let { error -&gt;\n            Card(\n                modifier = Modifier\n                    .align(Alignment.BottomCenter)\n                    .padding(16.dp)\n            ) {\n                Text(\n                    text = \"Error: $error\",\n                    modifier = Modifier.padding(16.dp),\n                    color = MaterialTheme.colorScheme.error\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/client-configuration/#migration-from-removed-api","title":"Migration from Removed API","text":"<p>The old callback-based API (passing callbacks directly to <code>ComposeWebView</code>) has been removed. You must migrate to the client configuration API.</p>"},{"location":"guides/client-configuration/#before-no-longer-supported","title":"Before (No Longer Supported)","text":"<pre><code>// \u274c This will no longer compile\nComposeWebView(\n    state = state,\n    onPageStarted = { ... },\n    onPageFinished = { ... },\n    onProgressChanged = { ... }\n)\n</code></pre>"},{"location":"guides/client-configuration/#after-recommended","title":"After (Recommended)","text":"<pre><code>// \u2705 Use rememberWebViewClient and rememberWebChromeClient\nval client = rememberWebViewClient {\n    onPageStarted { ... }\n    onPageFinished { ... }\n}\n\nval chromeClient = rememberWebChromeClient {\n    onProgressChanged { ... }\n}\n\nComposeWebView(\n    state = state,\n    client = client,\n    chromeClient = chromeClient\n)\n</code></pre> <p>Note: The direct callback parameters have been removed to cleaner API surface and better separation of concerns.</p>"},{"location":"guides/client-configuration/#see-also","title":"See Also","text":"<ul> <li>State Management</li> <li>Error Handling</li> <li>Lifecycle Management</li> <li>Features Guide</li> </ul>"},{"location":"guides/errors/","title":"Error Handling","text":"<p>Handling network errors or page load failures gracefully is essential for a robust app. <code>compose-webview</code> provides mechanisms to observe errors and display custom UI.</p>"},{"location":"guides/errors/#platform-support","title":"Platform Support","text":"Feature Android iOS Desktop Web Notes Typed Error Handling \u2705 Full \u2705 Full \u26a0\ufe0f Partial \u26a0\ufe0f Limited Structured error information <code>onReceivedError</code> Callback \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f Platform-specific error objects <code>errorContent</code> UI \u2705 \u2705 \u2705 \u2705 Custom error display HTTP Error Detection \u2705 \u2705 \u26a0\ufe0f \u274c Via <code>onReceivedHttpError</code>"},{"location":"guides/errors/#webviewerror-data-class","title":"WebViewError Data Class","text":"<p>All errors are wrapped in a typed <code>WebViewError</code> data class for consistent handling across platforms:</p> <pre><code>data class WebViewError(\n    val errorCode: Int,           // Platform-specific error code\n    val description: String,      // Human-readable description\n    val failingUrl: String? = null // The URL that failed to load\n)\n</code></pre> <p>Platform-Specific Error Codes:</p> <ul> <li>Android: Maps to <code>WebViewClient</code> error constants (e.g., <code>ERROR_HOST_LOOKUP</code>, <code>ERROR_CONNECT</code>, <code>ERROR_TIMEOUT</code>)</li> <li>iOS: Maps to <code>NSURLError</code> codes (e.g., <code>NSURLErrorNotConnectedToInternet</code>, <code>NSURLErrorTimedOut</code>)</li> <li>Desktop/Web: Limited error information available</li> </ul>"},{"location":"guides/errors/#observing-errors","title":"Observing Errors","text":"<p>You can listen for errors via the <code>onReceivedError</code> callback. This corresponds to the standard <code>WebViewClient.onReceivedError</code>.</p> <pre><code>val client = rememberWebViewClient {\n    onReceivedError { view, request, error -&gt;\n        // platform-specific types:\n        // request: PlatformWebResourceRequest?\n        // error: PlatformWebResourceError?\n\n        println(\"Failed to load: ${error?.description}\")\n    }\n}\n\nComposeWebView(\n    url = \"https://example.com\",\n    client = client\n)\n</code></pre> <p>Accessing Typed Errors:</p> <pre><code>val state = rememberWebViewState(url = \"https://example.com\")\n\n// Access errors from state\nLaunchedEffect(state.errorsForCurrentRequest) {\n    state.errorsForCurrentRequest.forEach { error -&gt;\n        println(\"Error ${error.errorCode}: ${error.description}\")\n        println(\"Failed URL: ${error.failingUrl}\")\n    }\n}\n</code></pre>"},{"location":"guides/errors/#displaying-custom-error-ui","title":"Displaying Custom Error UI","text":"<p>Instead of showing the default (and often ugly) browser error page, you can replace the WebView content with your own Composable when an error occurs.</p> <p>Use the <code>errorContent</code> parameter.</p> <pre><code>ComposeWebView(\n    url = \"https://example.com\",\n    errorContent = { errors -&gt;\n        // errors is a List&lt;WebViewError&gt;\n\n        Box(\n            modifier = Modifier.fillMaxSize(),\n            contentAlignment = Alignment.Center\n        ) {\n            Column(horizontalAlignment = Alignment.CenterHorizontally) {\n                Icon(\n                    imageVector = Icons.Default.Warning,\n                    contentDescription = null,\n                    tint = Color.Red,\n                    modifier = Modifier.size(48.dp)\n                )\n\n                Spacer(modifier = Modifier.height(16.dp))\n\n                Text(\n                    text = \"Page Loading Failed\",\n                    style = MaterialTheme.typography.headlineMedium\n                )\n\n                Text(\n                    text = errors.firstOrNull()?.description ?: \"Unknown Error\",\n                    style = MaterialTheme.typography.bodyMedium\n                )\n\n                Spacer(modifier = Modifier.height(16.dp))\n\n                Button(onClick = { controller.reload() }) {\n                    Text(\"Retry\")\n                }\n            }\n        }\n    }\n)\n</code></pre> <p>State Access</p> <p>The <code>errors</code> list passed to <code>errorContent</code> is also available via <code>state.errorsForCurrentRequest</code>.</p>"},{"location":"guides/errors/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"guides/errors/#1-network-disconnected","title":"1. Network Disconnected","text":"<p>You might want to check for network connectivity before even trying to load the URL, but if the connection drops during load, <code>ERROR_HOST_LOOKUP</code> or <code>ERROR_CONNECT</code> will occur.</p>"},{"location":"guides/errors/#2-http-errors-4xx-5xx","title":"2. HTTP Errors (4xx, 5xx)","text":"<p>Standard <code>WebView</code> does not treat HTTP errors (like 404 or 500) as \"Resource Errors\" in <code>onReceivedError</code>. Instead, they are valid responses.</p> <p>To handle these, you would typically need to inspect <code>onReceivedHttpError</code> in a custom <code>WebViewClient</code>.</p> <pre><code>client = remember {\n    object : ComposeWebViewClient() {\n        override fun onReceivedHttpError(\n            view: WebView?,\n            request: WebResourceRequest?,\n            errorResponse: WebResourceResponse?\n        ) {\n            super.onReceivedHttpError(view, request, errorResponse)\n            // Handle HTTP error (e.g., show a toast or tracking)\n            Log.e(\"WebView\", \"HTTP Error: ${errorResponse?.statusCode}\")\n        }\n    }\n}\n</code></pre>"},{"location":"guides/features/","title":"Advanced Features","text":"<p>This guide covers advanced capabilities of <code>compose-webview</code> including WebView Configuration, State Management, JavaScript Debugging, File Uploads, Downloads, and Custom Views (Fullscreen Video).</p>"},{"location":"guides/features/#platform-support-matrix","title":"Platform Support Matrix","text":"Feature Android iOS Desktop Web WebViewSettings Configuration \u2705 \u26a0\ufe0f \u26a0\ufe0f \u274c Console Message Debugging \u2705 \u2705 \u274c \u274c Scroll Position Tracking \u2705 \u2705 \u274c \u26a0\ufe0f Loading State with Progress \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f Typed Error Handling \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f File Uploads \u2705 \u2705 \u274c \u274c Downloads \u2705 \u26a0\ufe0f \u274c \u274c Custom View (Fullscreen) \u2705 \u274c \u274c \u274c JS Dialogs (Alert/Confirm/Prompt) \u2705 \u2705 \u274c \u274c <p>Legend: \u2705 Full Support | \u26a0\ufe0f Partial/Limited | \u274c Not Supported</p>"},{"location":"guides/features/#webview-configuration-webviewsettings","title":"WebView Configuration (WebViewSettings)","text":"<p>Configure WebView behavior with a unified API across platforms.</p>"},{"location":"guides/features/#basic-usage","title":"Basic Usage","text":"<pre><code>val settings = WebViewSettings(\n    userAgent = \"MyApp/1.0\",\n    javaScriptEnabled = true,\n    domStorageEnabled = true,\n    cacheMode = CacheMode.CACHE_ELSE_NETWORK,\n    supportZoom = true,\n    mediaPlaybackRequiresUserAction = false\n)\n\nComposeWebView(\n    state = webViewState,\n    settings = settings\n)\n</code></pre>"},{"location":"guides/features/#available-settings","title":"Available Settings","text":"Setting Android iOS Desktop Web Notes <code>userAgent</code> \u2705 \u2705 \u2705 \u274c Custom user agent string <code>javaScriptEnabled</code> \u2705 \u2705* \u2705 \u274c *iOS: Always enabled <code>domStorageEnabled</code> \u2705 \u2705 \u26a0\ufe0f \u274c localStorage/sessionStorage <code>cacheMode</code> \u2705 \u26a0\ufe0f \u26a0\ufe0f \u274c Cache behavior control <code>supportZoom</code> \u2705 \u26a0\ufe0f** \u2705 \u274c **iOS: Pinch-to-zoom only <code>mediaPlaybackRequiresUserAction</code> \u2705 \u2705 \u26a0\ufe0f \u274c Autoplay control <p>Platform-Specific Behavior</p> <ul> <li>iOS: JavaScript is always enabled and cannot be disabled. The <code>javaScriptEnabled</code> setting is ignored.</li> <li>iOS: Programmatic zoom (<code>zoomIn()</code>/<code>zoomOut()</code>) is not supported. Only user pinch-to-zoom gestures work.</li> <li>Web: Settings are browser-controlled and cannot be modified from the iframe.</li> </ul>"},{"location":"guides/features/#cache-modes","title":"Cache Modes","text":"<pre><code>enum class CacheMode {\n    DEFAULT,              // Use cache when available\n    CACHE_ELSE_NETWORK,  // Prefer cache, fallback to network\n    NO_CACHE,            // Always load from network\n    CACHE_ONLY           // Only use cache, don't fetch\n}\n</code></pre>"},{"location":"guides/features/#console-message-debugging","title":"Console Message Debugging","text":"<p>Capture and debug JavaScript console messages from your WebView.</p>"},{"location":"guides/features/#platform-support","title":"Platform Support","text":"Platform Status Implementation Android \u2705 Full <code>WebChromeClient.onConsoleMessage</code> iOS \u2705 Full Custom message handler Desktop/Web \u274c Not supported -"},{"location":"guides/features/#usage","title":"Usage","text":"<pre><code>@Composable\nfun DebuggableWebView() {\n    val state = rememberSaveableWebViewState(url = \"https://example.com\")\n\n    // Create handling chrome client\n    val chromeClient = rememberWebChromeClient {\n        onConsoleMessage { webView, message -&gt;\n            when (message.level) {\n                ConsoleMessageLevel.ERROR -&gt; {\n                    Log.e(\"WebView\", \"[${message.sourceId}:${message.lineNumber}] ${message.message}\")\n                }\n                ConsoleMessageLevel.WARNING -&gt; {\n                    Log.w(\"WebView\", message.message)\n                }\n                ConsoleMessageLevel.LOG -&gt; {\n                    Log.d(\"WebView\", message.message)\n                }\n                else -&gt; {\n                    Log.v(\"WebView\", message.message)\n                }\n            }\n            false // Return true to suppress default logging\n        }\n    }\n\n    ComposeWebView(\n        state = state,\n        chromeClient = chromeClient\n    )\n}\n</code></pre>"},{"location":"guides/features/#consolemessage-data-class","title":"ConsoleMessage Data Class","text":"<pre><code>data class ConsoleMessage(\n    val message: String,           // Console message text\n    val sourceId: String = \"\",     // Source file URL\n    val lineNumber: Int = 0,       // Line number in source\n    val level: ConsoleMessageLevel // Severity level\n)\n\nenum class ConsoleMessageLevel {\n    LOG, DEBUG, WARNING, ERROR, TIP\n}\n</code></pre>"},{"location":"guides/features/#scroll-position-tracking","title":"Scroll Position Tracking","text":"<p>Track the WebView's scroll position in real-time.</p>"},{"location":"guides/features/#platform-support_1","title":"Platform Support","text":"Platform Support Implementation Update Frequency Android \u2705 Full <code>setOnScrollChangeListener</code> Real-time iOS \u2705 Full <code>contentOffset</code> polling 100ms intervals Desktop \u274c Not supported CEF limitations - Web \u26a0\ufe0f Limited <code>onscroll</code> event CORS restricted (same-origin only)"},{"location":"guides/features/#usage_1","title":"Usage","text":"<pre><code>val webViewState = rememberWebViewState(url = \"https://example.com\")\n\n// Access scroll position from state\nLaunchedEffect(webViewState.scrollPosition) {\n    val (x, y) = webViewState.scrollPosition\n    println(\"Scrolled to: x=$x, y=$y\")\n}\n\nComposeWebView(state = webViewState)\n</code></pre>"},{"location":"guides/features/#scrollposition-data-class","title":"ScrollPosition Data Class","text":"<pre><code>@Immutable\ndata class ScrollPosition(\n    val x: Int = 0,  // Horizontal scroll position in pixels\n    val y: Int = 0   // Vertical scroll position in pixels\n)\n</code></pre> <p>Platform Limitations</p> <ul> <li>iOS: Uses polling (100ms intervals) instead of real-time updates due to Kotlin/Native KVO complexity.</li> <li>Web: Only works for same-origin iframes. Cross-origin iframes will always report (0, 0) due to CORS restrictions.</li> <li>Desktop: Not supported due to KCEF API limitations.</li> </ul>"},{"location":"guides/features/#file-uploads","title":"File Uploads","text":"<p>Uploading files (e.g., via <code>&lt;input type=\"file\"&gt;</code>) is often a hassle to implement in Android WebViews because it requires handling <code>WebChromeClient.onShowFileChooser</code>.</p>"},{"location":"guides/features/#platform-support_2","title":"Platform Support","text":"Platform Status Notes Android \u2705 Automatic Uses <code>onShowFileChooser</code> internally iOS \u2705 Native WKWebView handles file uploads by default Desktop/Web \u274c Not supported"},{"location":"guides/features/#how-it-works-android","title":"How it works (Android)","text":"<p>The library internally uses <code>rememberLauncherForActivityResult</code> to launch the Android File Picker intent when the WebView requests a file. When the user selects a file, the result is automatically passed back to the WebView.</p> <p>No Extra Code</p> <p>You do NOT need to implement <code>onShowFileChooser</code> or handle Activity results manually. It works out-of-the-box.</p>"},{"location":"guides/features/#how-it-works-ios","title":"How it works (iOS)","text":"<p>iOS's <code>WKWebView</code> natively supports file uploads without any additional configuration. The system automatically presents a file picker when a web page requests file input.</p> <p>iOS 18.4+ Custom Implementation</p> <p>Starting from iOS 18.4, you can optionally implement <code>WKUIDelegate.runOpenPanelWith</code> for custom file picker UI. However, this is not required for basic file upload functionality.</p>"},{"location":"guides/features/#permissions","title":"Permissions","text":"<p>Standard Android file picking usually does not require runtime permissions on modern Android versions (API 21+). However, if your web page requests camera access (e.g., <code>&lt;input type=\"file\" capture&gt;</code>), ensure you have declared and requested <code>CAMERA</code> permission in your app.</p>"},{"location":"guides/features/#downloads","title":"Downloads","text":"<p>By default, <code>WebView</code> does not handle file downloads. You need to provide a callback to intercept download requests.</p>"},{"location":"guides/features/#handling-downloads","title":"Handling Downloads","text":"<p>Use the <code>onDownloadStart</code> parameter to receive download events.</p> <pre><code>ComposeWebView(\n    url = \"https://example.com\",\n    onDownloadStart = { url, userAgent, contentDisposition, mimeType, contentLength -&gt;\n        // Trigger download\n        downloadFile(url, contentDisposition, mimeType)\n    }\n)\n</code></pre>"},{"location":"guides/features/#example-implementation","title":"Example Implementation","text":"<p>You can use Android's <code>DownloadManager</code> to handle the actual download.</p> <pre><code>fun downloadFile(context: Context, url: String, contentDisposition: String?, mimeType: String?) {\n    val request = DownloadManager.Request(Uri.parse(url))\n    request.setMimeType(mimeType)\n    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)\n\n    // Guess filename\n    val filename = URLUtil.guessFileName(url, contentDisposition, mimeType)\n    request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename)\n\n    val dm = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager\n    dm.enqueue(request)\n}\n</code></pre>"},{"location":"guides/features/#custom-views-fullscreen-video","title":"Custom Views (Fullscreen Video)","text":"<p>To support fullscreen video (e.g., YouTube's fullscreen button), you need to handle \"Custom Views\".</p>"},{"location":"guides/features/#1-provide-custom-view-content","title":"1. Provide Custom View Content","text":"<p>Use the <code>customViewContent</code> parameter. This lambda is only called when a video requests fullscreen.</p> <pre><code>ComposeWebView(\n    // ...\n    customViewContent = { customViewState -&gt;\n        // customViewState.customView is the video implementation provided by WebView\n        if (customViewState.customView != null) {\n            AndroidView(\n                factory = { customViewState.customView!! },\n                modifier = Modifier\n                    .fillMaxSize()\n                    .background(Color.Black) // Background for fullscreen\n            )\n        }\n    }\n)\n</code></pre>"},{"location":"guides/features/#2-android-manifest-configuration","title":"2. Android Manifest Configuration","text":"<p>For fullscreen video to work smoothly (and to allow orientation changes), your Activity in <code>AndroidManifest.xml</code> should handle configuration changes manually.</p> <pre><code>&lt;activity\n    android:name=\".MainActivity\"\n    android:configChanges=\"orientation|screenSize|keyboardHidden|smallestScreenSize|screenLayout\"\n    android:hardwareAccelerated=\"true\"&gt; &lt;!-- Required for video --&gt;\n</code></pre>"},{"location":"guides/js-bridge/","title":"JavaScript Bridge","text":"<p>One of the most powerful features of <code>compose-webview</code> is its Promise-based JavaScript Bridge. It simplifies communication between your Kotlin code and the JavaScript running inside the WebView.</p> <p>Mobile First</p> <p>The JSBridge is highly optimized for Android and iOS, providing a unified API. Support for Web and Desktop is currently experimental.</p>"},{"location":"guides/js-bridge/#concept","title":"Concept","text":"<p>Traditional <code>JavascriptInterface</code> (Android) or <code>WKScriptMessageHandler</code> (iOS) often leads to callback hell or requires complex JSON parsing manually.</p> <p>Our bridge solves this by:</p> <ol> <li>Promises: All calls from JS return a Promise, allowing <code>await</code> syntax.</li> <li>Serialization: Automatic JSON conversion for arguments and return values.</li> <li>Type Safety: Define your data models in Kotlin once.</li> </ol>"},{"location":"guides/js-bridge/#setup","title":"Setup","text":""},{"location":"guides/js-bridge/#1-define-data-models","title":"1. Define Data Models","text":"<p>Use <code>@Serializable</code> from <code>kotlinx.serialization</code> to define the data structures you want to pass.</p> <pre><code>@Serializable\ndata class User(val id: String, val name: String)\n\n@Serializable\ndata class DeviceInfo(val model: String, val osVersion: String)\n</code></pre>"},{"location":"guides/js-bridge/#2-create-the-bridge","title":"2. Create the Bridge","text":"<p>Create a bridge instance using <code>rememberWebViewJsBridge</code>. You can optionally customize the JavaScript object name (default is <code>window.AppBridge</code>).</p> <pre><code>val bridge = rememberWebViewJsBridge(\n    jsObjectName = \"MyApp\" // JS will access via window.MyApp\n)\n</code></pre>"},{"location":"guides/js-bridge/#receiving-calls-from-javascript","title":"Receiving Calls from JavaScript","text":"<p>Use the <code>register</code> function to define handlers for JavaScript calls.</p>"},{"location":"guides/js-bridge/#typed-handling-recommended","title":"Typed Handling (Recommended)","text":"<p>Specify the input type <code>T</code> and output type <code>R</code>. The library handles JSON parsing automatically.</p> <pre><code>LaunchedEffect(bridge) {\n    // JS: await window.MyApp.call('getUser', { id: '123' })\n    bridge.register&lt;UserRequest, User&gt;(\"getUser\") { request -&gt;\n        // This block runs in a coroutine\n        val user = userRepository.findById(request.id)\n        user // Returned value is sent back to JS\n    }\n}\n</code></pre>"},{"location":"guides/js-bridge/#no-return-value","title":"No Return Value","text":"<p>If your handler doesn't return anything (void), use <code>Unit</code> as the return type.</p> <pre><code>// JS: await window.MyApp.call('log', 'Hello')\nbridge.register&lt;String, Unit&gt;(\"log\") { message -&gt;\n    Log.d(\"WebView\", \"JS Log: $message\")\n}\n</code></pre>"},{"location":"guides/js-bridge/#calling-javascript-from-kotlin","title":"Calling JavaScript from Kotlin","text":"<p>You can also send events or execute arbitrary JavaScript.</p>"},{"location":"guides/js-bridge/#emitting-events","title":"Emitting Events","text":"<p>You can \"emit\" events that JavaScript can listen to.</p> <p>Kotlin:</p> <pre><code>bridge.emit(\"onNetworkStatusChange\", NetworkStatus(online = true))\n</code></pre> <p>JavaScript:</p> <pre><code>window.MyApp.on('onNetworkStatusChange', (status) =&gt; {\n    console.log(\"Is Online:\", status.online);\n});\n</code></pre>"},{"location":"guides/js-bridge/#evaluating-javascript","title":"Evaluating JavaScript","text":"<p>Execute raw JavaScript code.</p> <pre><code>controller.evaluateJavascript(\"alert('Hello from Kotlin!')\") { result -&gt;\n    println(\"Result: $result\")\n}\n</code></pre>"},{"location":"guides/js-bridge/#javascript-api-reference","title":"JavaScript API Reference","text":"<p>The bridge injects a global object (default <code>AppBridge</code>) into the WebView.</p>"},{"location":"guides/js-bridge/#callhandlername-data","title":"<code>call(handlerName, data)</code>","text":"<p>Calls a native handler registered in Kotlin. Returns a <code>Promise</code>.</p> <pre><code>try {\n    const result = await window.AppBridge.call('getUser', { id: 1 });\n    console.log(result);\n} catch (error) {\n    console.error(\"Native error:\", error);\n}\n</code></pre>"},{"location":"guides/js-bridge/#oneventname-callback","title":"<code>on(eventName, callback)</code>","text":"<p>Subscribes to an event emitted from Kotlin.</p> <pre><code>const unsubscribe = window.AppBridge.on('eventName', (data) =&gt; {\n    // Handle event\n});\n\n// Later...\nunsubscribe();\n</code></pre>"},{"location":"guides/js-bridge/#custom-json-serializer","title":"Custom JSON Serializer","text":"<p>By default, the library uses <code>kotlinx.serialization</code>. If you prefer Gson, Moshi, or Jackson, you can implement the <code>BridgeSerializer</code> interface.</p> <pre><code>class GsonSerializer(val gson: Gson) : BridgeSerializer {\n    override fun &lt;T&gt; encode(value: T, clazz: Class&lt;T&gt;): String = gson.toJson(value)\n    override fun &lt;T&gt; decode(json: String, clazz: Class&lt;T&gt;): T = gson.fromJson(json, clazz)\n}\n\n// Usage\nval bridge = rememberWebViewJsBridge(serializer = GsonSerializer(Gson()))\n</code></pre>"},{"location":"guides/lifecycle/","title":"Lifecycle Management","text":"<p>This guide explains how <code>compose-webview</code> manages the lifecycle of the underlying WebView instance and how it integrates with the Android lifecycle.</p>"},{"location":"guides/lifecycle/#automatic-lifecycle-handling","title":"Automatic Lifecycle Handling","text":"<p>Managing the lifecycle of a <code>WebView</code> is critical for performance and preventing memory leaks. Standard Android <code>WebView</code> requires manual calls to <code>onResume</code>, <code>onPause</code>, and <code>destroy</code>.</p> <p><code>compose-webview</code> handles all of this automatically within the Composable.</p>"},{"location":"guides/lifecycle/#1-resume-pause","title":"1. Resume &amp; Pause","text":"<ul> <li>On Resume: When your App or Composable comes to the foreground, <code>webView.onResume()</code> is called. This resumes JavaScript execution, timers, and any active layout processing.</li> <li>On Pause: When your App goes to the background or the Composable is hidden, <code>webView.onPause()</code> is called. This suspends JavaScript and reduces battery consumption.</li> </ul>"},{"location":"guides/lifecycle/#2-destruction-dispose","title":"2. Destruction (Dispose)","text":"<ul> <li>On Dispose: When the <code>ComposeWebView</code> leaves the composition tree (e.g., navigating to another screen), <code>webView.destroy()</code> is called.</li> <li>Cleanup: DOM storage and other resources are cleaned up to prevent memory leaks.</li> </ul> <p>Zero Boilerplate</p> <p>You do NOT need to manually handle lifecycle events in your Activity or Fragment.</p>"},{"location":"guides/lifecycle/#manual-control","title":"Manual Control","text":"<p>If you need to manually dispose of the WebView or clear its state before the Composable is removed, you can use the <code>onDispose</code> callback.</p> <pre><code>ComposeWebView(\n    // ...\n    onDispose = { webView -&gt;\n        // Additional cleanup if needed\n        webView.clearCache(true)\n        webView.clearHistory()\n\n        // Note: webView.destroy() is called automatically after this block\n    }\n)\n</code></pre>"},{"location":"guides/state-management/","title":"State Management","text":"<p>Managing the state of a WebView (URL, history, scroll position) is crucial for a smooth user experience, especially in a Compose environment where recompositions and configuration changes occur frequently.</p> <p><code>compose-webview</code> provides two distinct approaches to state management.</p>"},{"location":"guides/state-management/#1-persistent-state-recommended","title":"1. Persistent State (Recommended)","text":"<p>Use <code>rememberSaveableWebViewState</code> when you want the WebView to survive configuration changes (like screen rotation). This is the standard behavior users expect from a browser.</p>"},{"location":"guides/state-management/#features","title":"Features","text":"<ul> <li>Persistence: Automatically saves and restores state via <code>SavedStateHandle</code>.</li> <li>Safety: Handles lifecycle cleanup to prevent memory leaks.</li> </ul>"},{"location":"guides/state-management/#usage","title":"Usage","text":"<pre><code>// Automatically saved across rotations\nval state = rememberSaveableWebViewState(\n    url = \"https://google.com\",\n    additionalHttpHeaders = mapOf(\"X-Custom-Header\" to \"Value\")\n)\n\nComposeWebView(state = state)\n</code></pre>"},{"location":"guides/state-management/#loading-html-data","title":"Loading HTML Data","text":"<p>To load raw HTML content with persistence:</p> <pre><code>val state = rememberSaveableWebViewStateWithData(\n    data = \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\",\n    baseUrl = \"https://example.com\" // Optional Base URL\n)\n</code></pre>"},{"location":"guides/state-management/#2-transient-state-lightweight","title":"2. Transient State (Lightweight)","text":"<p>Use <code>rememberWebViewState</code> when you do not need persistence or if you are loading very large HTML data.</p>"},{"location":"guides/state-management/#when-to-use","title":"When to use?","text":"<ul> <li>Large Data: Android's <code>Bundle</code> has a size limit (approx 1MB). Trying to save a large HTML string in <code>rememberSaveable</code> will crash the app with <code>TransactionTooLargeException</code>.</li> <li>Temporary Views: For simple \"About\" screens or ToS pages where resetting on rotation is acceptable.</li> </ul>"},{"location":"guides/state-management/#features_1","title":"Features","text":"<ul> <li>Lightweight: No serialization overhead.</li> <li>Reset on Rotation: The WebView will reload from scratch if the screen rotates.</li> </ul>"},{"location":"guides/state-management/#usage_1","title":"Usage","text":"<pre><code>// Will reload if screen rotates\nval state = rememberWebViewState(url = \"https://google.com\")\n\nComposeWebView(state = state)\n</code></pre>"},{"location":"guides/state-management/#accessing-state-properties","title":"Accessing State Properties","text":"<p>The <code>WebViewState</code> object exposes reactive properties that you can observe in your Composables.</p>"},{"location":"guides/state-management/#available-properties","title":"Available Properties","text":"Property Type Description Platform Support <code>lastLoadedUrl</code> <code>String?</code> The URL currently loaded in the WebView. All platforms <code>isLoading</code> <code>Boolean</code> <code>true</code> if a page is currently loading. All platforms <code>loadingState</code> <code>LoadingState</code> Detailed loading progress (Initializing, Loading, Finished, Failed, Cancelled). All platforms* <code>pageTitle</code> <code>String?</code> The title of the current page. All platforms <code>pageIcon</code> <code>PlatformBitmap?</code> The favicon of the current page. Android, iOS, Desktop <code>scrollPosition</code> <code>ScrollPosition</code> Current scroll position (x, y) in pixels. Android (real-time), iOS (100ms polling), Web (CORS-limited)** <code>errorsForCurrentRequest</code> <code>SnapshotStateList&lt;WebViewError&gt;</code> List of errors encountered during the current load. Android, iOS, Desktop (partial), Web (limited) <code>jsDialogState</code> <code>JsDialogState?</code> Active JavaScript dialog (Alert, Confirm, Prompt). Android, iOS <code>customViewState</code> <code>CustomViewState?</code> Custom view state (e.g., fullscreen video). Android <p>* LoadingState progress: Android (real-time), iOS (100ms polling), Desktop/Web (limited) ** Web scrollPosition: Only works for same-origin iframes due to CORS restrictions</p>"},{"location":"guides/state-management/#example-observing-loading-progress","title":"Example: Observing Loading Progress","text":"<pre><code>val state = rememberSaveableWebViewState(url = \"https://example.com\")\n\nif (state.isLoading) {\n    val progress = (state.loadingState as? LoadingState.Loading)?.progress ?: 0f\n    LinearProgressIndicator(progress = progress)\n}\n</code></pre>"},{"location":"guides/state-management/#example-tracking-scroll-position","title":"Example: Tracking Scroll Position","text":"<pre><code>val state = rememberSaveableWebViewState(url = \"https://example.com\")\n\n// Observe scroll position changes\nLaunchedEffect(state.scrollPosition) {\n    val (x, y) = state.scrollPosition\n    println(\"User scrolled to: x=$x, y=$y\")\n\n    // Example: Show \"Back to Top\" button when scrolled down\n    if (y &gt; 500) {\n        showBackToTopButton = true\n    }\n}\n\nComposeWebView(state = state)\n</code></pre> <p>Platform-Specific Behavior:</p> <ul> <li>Android: Scroll position updates in real-time via <code>setOnScrollChangeListener</code></li> <li>iOS: Scroll position updates every 100ms via polling of <code>scrollView.contentOffset</code></li> <li>Desktop: Not supported (KCEF API limitations)</li> <li>Web: Only works for same-origin iframes; cross-origin iframes always report (0, 0) due to CORS</li> </ul>"}]}